#!/usr/bin/env bash
# ---------------------------------------------------------------------------
# Agent Safehouse Claude Desktop Launcher (generated file)
# Purpose: Launch Claude Desktop sandboxed to this file's directory.
#          Fetch latest apps policy from GitHub at runtime.
# Project: https://agent-safehouse.dev
# Generated by: scripts/generate-dist.sh
# ---------------------------------------------------------------------------
set -euo pipefail

claude_desktop_binary="/Applications/Claude.app/Contents/MacOS/Claude"
default_policy_url="https://raw.githubusercontent.com/eugene1g/agent-safehouse/main/dist/profiles/safehouse-for-apps.generated.sb"
project_url="https://agent-safehouse.dev"

validate_sb_string() {
  local value="$1"
  local label="${2:-SBPL string}"

  if [[ "$value" =~ [[:cntrl:]] ]]; then
    echo "Invalid ${label}: contains control characters and cannot be emitted into SBPL." >&2
    exit 1
  fi
}

escape_for_sb() {
  local value="$1"

  validate_sb_string "$value" "policy token" || exit 1
  value="${value//\\/\\\\}"
  value="${value//\"/\\\"}"
  printf '%s' "$value"
}

policy_checksum_256() {
  local path="$1"

  if command -v shasum >/dev/null 2>&1; then
    shasum -a 256 "$path" | awk '{print $1}'
    return 0
  fi

  if command -v sha256sum >/dev/null 2>&1; then
    sha256sum "$path" | awk '{print $1}'
    return 0
  fi

  if command -v openssl >/dev/null 2>&1; then
    openssl dgst -sha256 "$path" | awk '{print $NF}'
    return 0
  fi

  return 1
}

policy_checksum_matches() {
  local policy_path="$1"
  local expected="$2"
  local actual

  actual="$(policy_checksum_256 "$policy_path")" || return 1

  [[ "$actual" == "$expected" ]]
}

replace_literal_stream() {
  local from="$1"
  local to="$2"

  awk -v from="$from" -v to="$to" '
    {
      if (from == "") {
        print $0
        next
      }

      line = $0
      out = ""
      from_len = length(from)
      while ((idx = index(line, from)) > 0) {
        out = out substr(line, 1, idx - 1) to
        line = substr(line, idx + from_len)
      }

      print out line
    }
  '
}

fetch_remote_policy() {
  local url="$1"
  local output_path="$2"

  if command -v curl >/dev/null 2>&1; then
    if curl -fsSL --connect-timeout 10 --retry 2 --retry-delay 1 "$url" -o "$output_path"; then
      return 0
    fi
  fi

  if command -v wget >/dev/null 2>&1; then
    if wget -q -O "$output_path" "$url"; then
      return 0
    fi
  fi

  return 1
}

policy_template_looks_valid() {
  local policy_candidate="$1"

  [[ -f "$policy_candidate" ]] || return 1
  grep -Fq "(version 1)" "$policy_candidate" || return 1
  grep -Fq "(define HOME_DIR \"" "$policy_candidate" || return 1
  grep -Fq "#safehouse-test-id:electron-integration#" "$policy_candidate" || return 1

  return 0
}

emit_path_ancestor_literals() {
  local path_value="$1"
  local current="$path_value"
  local escaped
  local -a ancestors=()

  while true; do
    ancestors+=("$current")
    [[ "$current" == "/" ]] && break
    current="$(dirname "$current")"
  done

  local idx
  for ((idx=${#ancestors[@]} - 1; idx>=0; idx--)); do
    escaped="$(escape_for_sb "${ancestors[$idx]}")"
    printf '    (literal "%s")\n' "$escaped"
  done
}

main() {
  local home_dir launcher_workdir escaped_home escaped_workdir policy_source_path policy_path
  local remote_policy_url template_home_path policy_expected_sha256

  if [[ ! -x "$claude_desktop_binary" ]]; then
    echo "Claude Desktop binary not found at ${claude_desktop_binary}" >&2
    exit 1
  fi

  if ! command -v sandbox-exec >/dev/null 2>&1; then
    echo "sandbox-exec is required but was not found in PATH" >&2
    exit 1
  fi

  home_dir="${HOME:-}"
  if [[ -z "$home_dir" || ! -d "$home_dir" ]]; then
    echo "HOME must be set to an existing directory" >&2
    exit 1
  fi

  launcher_workdir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
  escaped_home="$(escape_for_sb "$home_dir")"
  escaped_workdir="$(escape_for_sb "$launcher_workdir")"
  policy_source_path="$(mktemp "/tmp/claude-safehouse-source-policy.XXXXXX")"
  policy_path="$(mktemp "/tmp/claude-safehouse-policy.XXXXXX")"

  cleanup_policy() {
    rm -f "$policy_source_path" "$policy_path"
  }
  trap cleanup_policy EXIT

  remote_policy_url="${SAFEHOUSE_CLAUDE_POLICY_URL:-$default_policy_url}"
  validate_sb_string "$remote_policy_url" "policy URL" || exit 1
  policy_expected_sha256="${SAFEHOUSE_CLAUDE_POLICY_SHA256:-}"
  if [[ -n "$policy_expected_sha256" ]]; then
    validate_sb_string "$policy_expected_sha256" "policy SHA-256" || exit 1
  fi

  if ! fetch_remote_policy "$remote_policy_url" "$policy_source_path"; then
    echo "Failed to download sandbox policy from ${remote_policy_url}" >&2
    echo "Install curl or wget, or set SAFEHOUSE_CLAUDE_POLICY_URL to a reachable policy URL." >&2
    echo "Help: ${project_url}" >&2
    exit 1
  fi
  if ! policy_template_looks_valid "$policy_source_path"; then
    echo "Downloaded policy is invalid: ${remote_policy_url}" >&2
    echo "Help: ${project_url}" >&2
    exit 1
  fi

  if [[ -n "$policy_expected_sha256" ]]; then
    if ! policy_checksum_matches "$policy_source_path" "$policy_expected_sha256"; then
      echo "Downloaded policy SHA-256 does not match SAFEHOUSE_CLAUDE_POLICY_SHA256." >&2
      echo "Expected: ${policy_expected_sha256}" >&2
      echo "Could not verify: install one of shasum/sha256sum/openssl." >&2
      exit 1
    fi
  fi

  template_home_path="$(awk -F'"' '/^\(define HOME_DIR "/ { print $2; exit }' "$policy_source_path")"
  if [[ -z "${template_home_path:-}" ]]; then
    echo "Failed to parse HOME_DIR from launcher policy source (${remote_policy_url})" >&2
    exit 1
  fi

  {
    replace_literal_stream "$template_home_path" "$escaped_home" < "$policy_source_path"
    cat <<'POLICY'

;; #safehouse-test-id:workdir-grant# Allow read/write access to the selected workdir.
;; Generated ancestor directory literals for selected workdir: ${launcher_workdir}
;; Why file-read* (not file-read-metadata) with literal (not subpath):
;; Agents (notably Claude Code) call readdir() on every ancestor of the working
;; directory to discover project structure. file-read-metadata on the leaf is not
;; enough; each ancestor directory itself must be traversable. literal confines
;; access to the directory entry only (no recursion), so this does not grant
;; recursive read access to files or subdirectories under it.
(allow file-read*
$(emit_path_ancestor_literals "$launcher_workdir")
)

(allow file-read* file-write* (subpath "$escaped_workdir"))
POLICY
  } > "$policy_path"

  cd "$launcher_workdir"
  sandbox-exec -f "$policy_path" -- "$claude_desktop_binary" --no-sandbox "$@"
}

main "$@"
