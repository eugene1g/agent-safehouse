#!/usr/bin/env bash
# ---------------------------------------------------------------------------
# Agent Safehouse Claude Desktop Launcher (generated file)
# Purpose: Launch Claude Desktop sandboxed to this file's directory.
#          Fetch latest apps policy from GitHub at runtime.
# Project: https://agent-safehouse.dev
# Source Commit: bf8580377da0ca3a71b2c6c414025a31d19db88f
# Generated by: scripts/generate-dist.sh
# ---------------------------------------------------------------------------
set -euo pipefail

claude_desktop_binary="/Applications/Claude.app/Contents/MacOS/Claude"
default_policy_url="https://raw.githubusercontent.com/eugene1g/agent-safehouse/main/dist/profiles/safehouse-for-apps.generated.sb"
project_url="https://agent-safehouse.dev"

escape_for_sb() {
  local value="$1"
  value="${value//\\/\\\\}"
  value="${value//\\"/\\\\"}"
  printf '%s' "$value"
}

replace_literal_stream() {
  local from="$1"
  local to="$2"

  awk -v from="$from" -v to="$to" '
    {
      line = $0
      while ((idx = index(line, from)) > 0) {
        line = substr(line, 1, idx - 1) to substr(line, idx + length(from))
      }
      print line
    }
  '
}

fetch_remote_policy() {
  local url="$1"
  local output_path="$2"

  if command -v curl >/dev/null 2>&1; then
    if curl -fsSL --connect-timeout 10 --retry 2 --retry-delay 1 "$url" -o "$output_path"; then
      return 0
    fi
  fi

  if command -v wget >/dev/null 2>&1; then
    if wget -q -O "$output_path" "$url"; then
      return 0
    fi
  fi

  return 1
}

policy_template_looks_valid() {
  local policy_candidate="$1"

  [[ -f "$policy_candidate" ]] || return 1
  grep -Fq "(version 1)" "$policy_candidate" || return 1
  grep -Fq "(define HOME_DIR \"" "$policy_candidate" || return 1
  grep -Fq "#safehouse-test-id:electron-integration#" "$policy_candidate" || return 1

  return 0
}

emit_path_ancestor_literals() {
  local path_value="$1"
  local current="$path_value"
  local escaped
  local -a ancestors=()

  while true; do
    ancestors+=("$current")
    [[ "$current" == "/" ]] && break
    current="$(dirname "$current")"
  done

  local idx
  for ((idx=${#ancestors[@]} - 1; idx>=0; idx--)); do
    escaped="$(escape_for_sb "${ancestors[$idx]}")"
    printf '    (literal "%s")\n' "$escaped"
  done
}

main() {
  local home_dir launcher_workdir escaped_home escaped_workdir policy_source_path policy_path
  local remote_policy_url template_home_path

  if [[ ! -x "$claude_desktop_binary" ]]; then
    echo "Claude Desktop binary not found at ${claude_desktop_binary}" >&2
    exit 1
  fi

  if ! command -v sandbox-exec >/dev/null 2>&1; then
    echo "sandbox-exec is required but was not found in PATH" >&2
    exit 1
  fi

  home_dir="${HOME:-}"
  if [[ -z "$home_dir" || ! -d "$home_dir" ]]; then
    echo "HOME must be set to an existing directory" >&2
    exit 1
  fi

  launcher_workdir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd -P)"
  escaped_home="$(escape_for_sb "$home_dir")"
  escaped_workdir="$(escape_for_sb "$launcher_workdir")"
  policy_source_path="$(mktemp "/tmp/claude-safehouse-source-policy.XXXXXX")"
  policy_path="$(mktemp "/tmp/claude-safehouse-policy.XXXXXX")"

  cleanup_policy() {
    rm -f "$policy_source_path" "$policy_path"
  }
  trap cleanup_policy EXIT

  remote_policy_url="${SAFEHOUSE_CLAUDE_POLICY_URL:-$default_policy_url}"
  if ! fetch_remote_policy "$remote_policy_url" "$policy_source_path"; then
    echo "Failed to download sandbox policy from ${remote_policy_url}" >&2
    echo "Install curl or wget, or set SAFEHOUSE_CLAUDE_POLICY_URL to a reachable policy URL." >&2
    echo "Help: ${project_url}" >&2
    exit 1
  fi
  if ! policy_template_looks_valid "$policy_source_path"; then
    echo "Downloaded policy is invalid: ${remote_policy_url}" >&2
    echo "Help: ${project_url}" >&2
    exit 1
  fi

  template_home_path="$(awk -F'"' '/^\(define HOME_DIR "/ { print $2; exit }' "$policy_source_path")"
  if [[ -z "${template_home_path:-}" ]]; then
    echo "Failed to parse HOME_DIR from launcher policy source (${remote_policy_url})" >&2
    exit 1
  fi

  {
    replace_literal_stream "$template_home_path" "$escaped_home" < "$policy_source_path"
    cat <<POLICY

;; #safehouse-test-id:workdir-grant# Allow read/write access to the selected workdir.
;; Generated ancestor directory literals for selected workdir: ${launcher_workdir}
;; Why file-read* (not file-read-metadata) with literal (not subpath):
;; Agents (notably Claude Code) call readdir() on every ancestor of the working
;; directory to discover project structure. file-read-metadata on the leaf is not
;; enough; each ancestor directory itself must be traversable. literal confines
;; access to the directory entry only (no recursion), so this does not grant
;; recursive read access to files or subdirectories under it.
(allow file-read*
$(emit_path_ancestor_literals "$launcher_workdir")
)

(allow file-read* file-write* (subpath "$escaped_workdir"))
POLICY
  } > "$policy_path"

  sandbox-exec -f "$policy_path" -- "$claude_desktop_binary" --no-sandbox "$@"
}

main "$@"
